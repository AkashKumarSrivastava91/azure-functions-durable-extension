// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.

using System;
using System.Diagnostics;
using System.Diagnostics.Tracing;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json.Linq;

namespace Microsoft.Azure.WebJobs.Extensions.DurableTask
{
    /// <summary>
    /// In charge of logging services for our linux App Service offerings: Consumption and Dedicated.
    /// In Consumption, we log to the console and identify our log by a prefix.
    /// In Dedicated, we log to a pre-defined logging path.
    /// This class is utilized by <c>EventSourceListener</c> to write logs corresponding to
    /// specific EventSource providers.
    /// </summary>
    internal class LinuxAppServiceLogger
    {
        private const string ConsolePrefix = "MS_DURABLE_FUNCTION_EVENTS_LOGS";
        internal const int MaxArchives = 5;
        private const int BytesToMb = 1024 * 1024;
        private readonly int maxLogfileSizeInMb;
#pragma warning disable SA1401 // Fields should be private
        internal readonly string LoggingPath;
#pragma warning restore SA1401 // Fields should be private

        // logging metadata
        private readonly JToken roleInstance;
        private readonly JToken tenant;
        private readonly JToken sourceMoniker;
        private readonly JToken procID;

        // if true, we write to console (linux consumption), else to a file (linux dedicated).
        private readonly bool writeToConsole;

        // the paths to all allowed archived log files.
        private readonly string[] archivedPaths = new string[MaxArchives];

        // the current number of archived log files
        private int countArchives;

        /// <summary>
        /// Create a LinuxAppServiceLogger instance.
        /// </summary>
        /// <param name="writeToConsole">If true, write to console (linux consumption) else to a file (dedicated).</param>
        /// <param name="containerName">The app's container name.</param>
        /// <param name="tenant">The app's tenant.</param>
        /// <param name="stampName">The app's stamp.</param>
        /// <param name="loggingPath">Path to log file in linux dedicated. Configurable for testing.</param>
        /// <param name="countArchives">Num of current archived files. Configurable for testing.</param>
        /// <param name="maxLogfileSizeInMb">Max size of logging file before archiving. Configurable for testing.</param>
        public LinuxAppServiceLogger(
            bool writeToConsole,
            string containerName,
            string tenant,
            string stampName,
            string loggingPath = "/var/log/functionsLogs/durableevents.log",
            int countArchives = 0,
            int maxLogfileSizeInMb = 10)
        {
            this.LoggingPath = loggingPath;
            this.countArchives = countArchives;
            this.maxLogfileSizeInMb = maxLogfileSizeInMb;

            // If writeToConsole is False, we write to a file
            for (int count = 1; count <= MaxArchives; count++)
            {
                string archivedPath = this.LoggingPath + count;
                this.archivedPaths[count - 1] = archivedPath;
            }

            // initializing fixetd logging metadata
            this.writeToConsole = writeToConsole;
            this.roleInstance = JToken.FromObject("App-" + containerName);
            this.tenant = JToken.FromObject(tenant);
            this.sourceMoniker = JToken.FromObject(
                string.IsNullOrEmpty(stampName) ? string.Empty : "L" + stampName.Replace("-", "").ToUpperInvariant());
            using (var process = Process.GetCurrentProcess())
            {
                this.procID = process.Id;
            }

            Directory.CreateDirectory(Path.GetDirectoryName(loggingPath));
            File.Create(loggingPath).Close();
        }

        /// <summary>
        /// Given EventSource message data, we generate a JSON-string that we can log.
        /// </summary>
        /// <param name="eventData">An EventSource message, usually generated by an EventListener.</param>
        /// <returns>A JSON-formatted string representing the input.</returns>
        private string GenerateJsonStr(EventWrittenEventArgs eventData)
        {
            var values = eventData.Payload;
            var keys = eventData.PayloadNames;

            // We pack them into a JSON
            JObject json = new JObject
            {
                { "EventId", eventData.EventId },
                { "TimeStamp", DateTime.UtcNow },
                { "RoleInstance", this.roleInstance },
                { "Tenant", this.tenant },
                { "SourceMoniker",  this.sourceMoniker },
                { "Pid", this.procID },
                { "Tid", Thread.CurrentThread.ManagedThreadId },
            };

            for (int i = 0; i < values.Count; i++)
            {
                json.Add(keys[i], JToken.FromObject(values[i]));
            }

            // Generate string-representation of JSON
            string jsonString = json.ToString(Newtonsoft.Json.Formatting.None);
            return jsonString;
        }

        /// <summary>
        /// Log EventSource message data in Linux AppService.
        /// </summary>
        /// <param name="eventData">An EventSource message, usually generated by an EventListener.</param>
        public void Log(EventWrittenEventArgs eventData)
        {
            // Generate JSON string to log based on the EventSource message
            string jsonString = this.GenerateJsonStr(eventData);

            // We write to console in Linux Consumption
            if (this.writeToConsole)
            {
                // We're ignoring exceptions in the unobserved Task
                string consoleLine = ConsolePrefix + " " + jsonString;
                Task unused = Console.Out.WriteLineAsync(consoleLine);
            }
            else
            {
                this.LogFileMaintenance();

                // We write to a file in Linux Dedicated
                var writer = new StreamWriter(this.LoggingPath, append: true);

                // We're ignoring exceptions in the unobserved Task
                Task unused = writer.WriteLineAsync(jsonString).ContinueWith(_ => writer.Dispose());
            }
        }

        internal void LogFileMaintenance()
        {
            // check that this is only done in right circumstances...
            // If the log file gets too big, we archive it.
            FileInfo logFileInfo = new FileInfo(this.LoggingPath);
            if (logFileInfo.Length / BytesToMb >= this.maxLogfileSizeInMb)
            {
                string archivedPath = this.archivedPaths[this.countArchives];
                File.Move(this.LoggingPath, archivedPath);
                this.countArchives++;
            }

            // If we have too many archived log files, we delete them
            if (this.countArchives >= MaxArchives)
            {
                foreach (string archivePath in this.archivedPaths)
                {
                    File.Delete(archivePath);
                }

                this.countArchives = 0;
            }
        }
    }
}
